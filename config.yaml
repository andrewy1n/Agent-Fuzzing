_meta:
  editable_keys:
    - path: fuzzer.seed_inputs
      type: list
    - path: fuzzer.execution_values
      type: list
      description: |
        List of execution state definitions. Each state can include:
        - name: semantic name of the state
        - read: read spec dictionary
            # for register-direct mode
            mode: register_direct
            capture_pc_offset: <hex_offset> # PC offset from image base where snapshot occurs (required for register modes)
            reg: <register_name>            # Register name (e.g., al, rax)
            size: <int>                     # Bytes to read

            # for mem_offset mode
            mode: mem_offset
            capture_pc_offset: <hex_offset> # PC offset from image base where snapshot occurs
            offset_from_image: <hex_offset> # Offset from image base to read
            size: <int>          # Bytes to read

            # for register_deref mode
            mode: register_deref
            capture_pc_offset: <hex_offset> # PC offset where pointer is loaded into register
            reg: <register_name>            # Register containing pointer
            ptr_size: <int>                  # Size of the pointer (bytes)
            size: <int>                      # Number of bytes to read at dereferenced address
        - valid_values:                      # Optional constraints to guide generator
            type: <enum|bytes|int|float>
            values: [<list_of_values>]       # for enums
            alphabet: [<allowed_bytes>]      # for bytes
            length: <int>                     # for bytes arrays
            signed: <true|false>             # for integers
            range: [<min>, <max>]            # for int/float ranges
        - notes: human-readable explanation
    - path: fuzzer.execution_state
      type: list
      description: |
        List of execution state definitions, they are either values, predicates, or sum.
        Each definition takes up a value in the execution state tuple.
        - type: predicate # boolean expression using <execution_value_name> and real values, operators: ==, !=, <, >, <=, >=, &&, ||
        - expr: # boolean expression using <execution_value_name> and real values, operators: ==, !=, <, >, <=, >=, &&, ||

        - type: value # last value of the given execution value name
        - name: <execution_value_name>

        - type: sum # sum of all values seen for the given execution value name
        - name: <execution_value_name>

        - type: counter # count of how many times the boolean expression is true
        - expr: # boolean expression using <execution_value_name> and real values, operators: ==, !=, <, >, <=, >=, &&, ||

        - type: set # set of all values seen for the given execution value name
        - name: <execution_value_name>

fuzzer:
  time_limit: 600
  execution_limit: 0
  per_run_timeout: 5
  coverage_plateau_timeout_seconds: 60
  mutations:
    num_mutations: 10
    server: http://localhost:8001
    operators_file: /home/andrewyin/qiling_tests/Agent-Fuzzing/operators.json
  seed_inputs:
  - '0,1 0,2

    '
  - '1,0 2,2

    '
  - '0,6 0,5

    '
  - '7,7 6,6

    '
  - '2,1 3,2

    '
  - '3,3 4,4

    '
  stdout: false
  execution_values:
  - name: move_qw1
    read:
      mode: register_direct
      capture_pc_offset: 13057
      reg: rdx
      size: 8
    valid_values:
      type: int
      range:
      - 0
      - 18446744073709551615
      signed: false
    notes: First 8 bytes of Move struct passed in RDX at performMove call site. Contains
      src.x (low 4 bytes) and src.y (high 4 bytes) as 32-bit integers; expected values
      0..7 for board coordinates.
  - name: move_qw2
    read:
      mode: register_direct
      capture_pc_offset: 13057
      reg: rax
      size: 8
    valid_values:
      type: int
      range:
      - 0
      - 18446744073709551615
      signed: false
    notes: Second 8 bytes of Move struct passed in RAX at performMove call site. Contains
      dst.x (low 4 bytes) and dst.y (high 4 bytes) as 32-bit integers; expected values
      0..7 for board coordinates.
  - name: current_team
    read:
      mode: mem_offset
      capture_pc_offset: 12884
      offset_from_image: 24576
      size: 1
    valid_values:
      type: enum
      values:
      - 0
      - 1
    notes: 'Global byte holding current_team: 1 = WHITE, 0 = BLACK. Reading at image-base
      + 0x6000.'
  execution_state:
  - type: value
    name: move_qw1
  - type: value
    name: move_qw2
  - type: value
    name: current_team

corpus_stat_tracker:
  snapshot_interval_seconds: 10

target:
  binary: 'samples/CROMU_00005'
  rootfs: 'rootfs/x8664_linux_glibc2.39'

input:
  method: 'stdin'

output:
  dir: 'out'

generator_agent:
  model: 'gpt-4.1-mini'
  system_prompt: |
    You are a mutation agent for a agent-driven fuzzer.
    Your job: given a seed input and feedback (good/bad examples), produce a diverse list of input mutations that are more like the good examples and less like the bad ones, with the goal of increasing execution state coverage.

    You will be given feedback from a critic agent that will guide you toward deeper execution states, make sure to follow the most recent instructions.

    Output format:
    - Return ONLY a JSON object that matches this schema: {"mutations": [string, ...]}.
    - Each element in "mutations" is a single test input as a UTF-8 string (it will be converted to bytes by the harness).
    - Do not include explanations, comments, or code fences.
  grammar_prompt: |
  goal_prompt: |

critic_agent:
  server: 'http://localhost:8000'
  thread_id: 'cgc::CROMU_00005::a5a8cc76-cf2b-41ab-8651-6e80d8617833'
  binary_path: 'cgc_bin/CROMU_00005'
  results_dir: ''
  initial_prompt: |
    You are a critic for a fuzzing mutation agent. 
    Your job is to analyze the results of a mutation session and provide concise, actionable guidance that will help the mutation agent generate inputs that reach deeper execution states.

    Inputs available to you:
    - The original seed inputs.
    - The mutation agent's generated inputs.
    - Feedback for each input (e.g., "good" if it reached a new execution state, "bad" if it failed or repeated previous states).
    - Any program state signals (e.g., branch coverage, flags, stage counters).

    Your instructions:
    1. Suggest specific directions for the mutation agent:
       - Fields or input sections to focus on mutating.
       - Types of mutations likely to produce new states.
       - Avoid mutations that repeatedly fail.
    2. Keep your message **short, precise, and actionable** — 1–3 sentences MAX.
    3. ONLY return the text of your message to the mutation agent. Do not explain your reasoning outside the message.

    Here are the results of the mutation session: