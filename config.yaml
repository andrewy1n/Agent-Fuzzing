_meta:
  editable_keys:
    - fuzzer.state_address_offset
    - fuzzer.state_reg
    - fuzzer.seed_inputs
    - generator_agent.grammar_prompt
    - generator_agent.goal_prompt

fuzzer:
  time_limit: 30
  execution_limit: 0
  per_run_timeout: 5
  mutations_per_seed: 4
  round_length: 10
  state_address_offset: 0
  state_reg: []
  seed_inputs: ['a']

corpus_stat_tracker:
  snapshot_interval_seconds: 10

target:
  binary: 'samples/CROMU_00005'
  rootfs: 'rootfs/x8664_linux_glibc2.39'

input:
  method: 'stdin'

output:
  dir: 'out'

generator_agent:
  model: 'gpt-5-nano'
  system_prompt: |
    You are a mutation agent for a agent-driven fuzzer.
    Your job: given a seed input and feedback (good/bad examples), produce a diverse list of input mutations that are more like the good examples and less like the bad ones, with the goal of increasing execution state coverage.

    You will be given feedback from a critic agent that will guide you toward deeper execution states, make sure to follow the most recent instructions.

    Output format:
    - Return ONLY a JSON object that matches this schema: {"mutations": [string, ...]}.
    - Each element in "mutations" is a single test input as a UTF-8 string (it will be converted to bytes by the harness).
    - Do not include explanations, comments, or code fences.
  grammar_prompt: |
  goal_prompt: |

summarizer_agent:
  model: 'gpt-5-mini'
  system_prompt: |
    You are a summarizer agent. Your task is to analyze all the mutation results from a fuzzer. 
    You are given two lists:
    1. Failed mutations (did not expand coverage).
    2. Successful mutations (expanded coverage).

    Your goal is to produce a concise, structured summary of the mutation results.

    ### Instructions:
    - Identify common **patterns in failures** (e.g., repeated sources, small shifts, 
      horizontal/vertical moves, etc.).
    - Identify common **patterns in successes** (e.g., diagonal jumps, moves from certain 
      rows/columns).
    - Provide a few **representative examples** of failed and successful mutations 
      (not the full list).

    Keep the summary short and clear.

    ### Input:
    Failed mutations:
    {failed_mutations}

    Successful mutations:
    {successful_mutations}

    ### Output format:
    Summary of last round:
    - Failed patterns: ...
    - Successful patterns: ...
    - Representative examples:
      - Successful: [...]
      - Failed: [...]

critic_agent:
  server: 'http://localhost:8000'
  thread_id: ''
  binary_path: ''
  results_dir: ''
  initial_prompt: |
    You are acting as the critic of a mutation agent. 
    You are given the results of a mutation session and you will send a message directly to the mutation agent to guide it toward deeper execution states.

    Analyze the input, execution state, and output of the results to see what the mutation could improve onto to reach deeper execution states.

    ONLY return the text of your message to the mutation agent. Keep your message short, concise but specific.

    The mutation agent is given a seed input and feedback (good/bad examples), and it needs to produce a diverse list of input mutations that are more like the good examples and less like the bad ones, with the goal of increasing execution state coverage.

    The initial prompt is:
    {initial_prompt}

    The results of the mutation session are:
    {results}