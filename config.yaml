_meta:
  editable_keys:
    - path: fuzzer.seed_inputs
      type: list
    - path: fuzzer.execution_state
      type: list
      description: |
        List of execution state definitions. Each state can include:
        - name: semantic name of the state
        - read: read spec dictionary
            # for register-direct mode
            mode: register_direct
            capture_pc_offset: <hex_offset> # PC offset from image base where snapshot occurs (required for register modes)
            reg: <register_name>            # Register name (e.g., al, rax)
            size: <int>                     # Bytes to read

            # for mem_offset mode
            mode: mem_offset
            capture_pc_offset: <hex_offset> # PC offset from image base where snapshot occurs
            offset_from_image: <hex_offset> # Offset from image base to read
            size: <int>          # Bytes to read

            # for register_deref mode
            mode: register_deref
            capture_pc_offset: <hex_offset> # PC offset where pointer is loaded into register
            reg: <register_name>            # Register containing pointer
            ptr_size: <int>                  # Size of the pointer (bytes)
            size: <int>                      # Number of bytes to read at dereferenced address
        - valid_values:                      # Optional constraints to guide generator
            type: <enum|bytes|int|float>
            values: [<list_of_values>]       # for enums
            alphabet: [<allowed_bytes>]      # for bytes
            length: <int>                     # for bytes arrays
            signed: <true|false>             # for integers
            range: [<min>, <max>]            # for int/float ranges
        - notes: human-readable explanation
    - path: generator_agent.grammar_prompt
      type: string
    - path: generator_agent.goal_prompt
      type: string

fuzzer:
  time_limit: 60
  execution_limit: 0
  per_run_timeout: 5
  mutations_per_seed: 4
  round_length: 10
  seed_inputs: ['1 1 1 2\n', '9\n', '7 1 7 3\n9\n']
  stdout: false
  execution_state:
    # Example 1: mem_offset - Capture current player from global variable (always accessible)
    - name: current_player_turn
      read:
        mode: mem_offset
        capture_pc_offset: 0x3244    # Right after initboard call - this will definitely execute
        offset_from_image: 0x6000    # Global current_team variable
        size: 1                      # 1 byte for player ID (0=white, 1=black)
      valid_values:
        type: enum
        values: [0, 1]               # 0=white, 1=black
      notes: "Captures current player turn from global variable"
    
    # Example 2: Final board capture - After all pieces are set
    - name: full_board_correct
      read:
        mode: register_deref
        capture_pc_offset: 0x2491    # Right after last piece is set, before function epilogue
        reg: rax                     # RAX contains ptr_array address + 0x3f
        ptr_size: 8                  # 64-bit pointer  
        size: 64                     # Read entire 8x8 board (64 bytes) 
      valid_values:
        type: bytes
        alphabet: [0x2e, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c]  # Chess pieces: '.', 'a'-'l'  
        length: 64                   # Exactly 64 bytes (8x8 board)
      notes: "Captures complete board after all pieces are initialized"

corpus_stat_tracker:
  snapshot_interval_seconds: 10

target:
  binary: 'samples/CROMU_00005'
  rootfs: 'rootfs/x8664_linux_glibc2.39'

input:
  method: 'stdin'

output:
  dir: 'out'

generator_agent:
  model: 'gpt-4.1-mini'
  system_prompt: |
    You are a mutation agent for a agent-driven fuzzer.
    Your job: given a seed input and feedback (good/bad examples), produce a diverse list of input mutations that are more like the good examples and less like the bad ones, with the goal of increasing execution state coverage.

    You will be given feedback from a critic agent that will guide you toward deeper execution states, make sure to follow the most recent instructions.

    Output format:
    - Return ONLY a JSON object that matches this schema: {"mutations": [string, ...]}.
    - Each element in "mutations" is a single test input as a UTF-8 string (it will be converted to bytes by the harness).
    - Do not include explanations, comments, or code fences.
  grammar_prompt: |
  goal_prompt: |

summarizer_agent:
  model: 'gpt-5-mini'
  system_prompt: |
    You are a summarizer agent. Your task is to analyze all the mutation results from a fuzzer. 
    You are given two lists:
    1. Failed mutations (did not expand coverage).
    2. Successful mutations (expanded coverage).

    Your goal is to produce a concise, structured summary of the mutation results.

    ### Instructions:
    - Identify common **patterns in failures** (e.g., repeated sources, small shifts, 
      horizontal/vertical moves, etc.).
    - Identify common **patterns in successes** (e.g., diagonal jumps, moves from certain 
      rows/columns).
    - Provide a few **representative examples** of failed and successful mutations 
      (not the full list).

    Keep the summary short and clear.

    ### Input:
    Failed mutations:
    {failed_mutations}

    Successful mutations:
    {successful_mutations}

    ### Output format:
    Summary of last round:
    - Failed patterns: ...
    - Successful patterns: ...
    - Representative examples:
      - Successful: [...]
      - Failed: [...]

critic_agent:
  server: 'http://localhost:8000'
  thread_id: ''
  binary_path: ''
  results_dir: ''
  initial_prompt: |
    You are a critic for a fuzzing mutation agent. 
    Your job is to analyze the results of a mutation session and provide concise, actionable guidance that will help the mutation agent generate inputs that reach deeper execution states.

    Inputs available to you:
    - The original seed inputs.
    - The mutation agent's generated inputs.
    - Feedback for each input (e.g., "good" if it reached a new execution state, "bad" if it failed or repeated previous states).
    - Any program state signals (e.g., branch coverage, flags, stage counters).

    Your instructions:
    1. Suggest specific directions for the mutation agent:
       - Fields or input sections to focus on mutating.
       - Types of mutations likely to produce new states.
       - Avoid mutations that repeatedly fail.
    2. Keep your message **short, precise, and actionable** — 1–3 sentences MAX.
    3. ONLY return the text of your message to the mutation agent. Do not explain your reasoning outside the message.

    Here are the results of the mutation session: