_meta:
  editable_keys:
    - path: fuzzer.seed_inputs
      type: list
    - path: fuzzer.execution_values
      type: list
      description: |
        List of execution state definitions. Each state can include:
        - name: semantic name of the state
        - read: read spec dictionary
            # for register-direct mode
            mode: register_direct
            capture_pc_offset: <hex_offset> # PC offset from image base where snapshot occurs (required for register modes)
            reg: <register_name>            # Register name (e.g., al, rax)
            size: <int>                     # Bytes to read

            # for mem_offset mode
            mode: mem_offset
            capture_pc_offset: <hex_offset> # PC offset from image base where snapshot occurs
            offset_from_image: <hex_offset> # Offset from image base to read
            size: <int>          # Bytes to read

            # for register_deref mode
            mode: register_deref
            capture_pc_offset: <hex_offset> # PC offset where pointer is loaded into register
            reg: <register_name>            # Register containing pointer
            ptr_size: <int>                  # Size of the pointer (bytes)
            size: <int>                      # Number of bytes to read at dereferenced address
        - valid_values:                      # Optional constraints to guide generator
            type: <enum|bytes|int|float>
            values: [<list_of_values>]       # for enums
            alphabet: [<allowed_bytes>]      # for bytes
            length: <int>                     # for bytes arrays
            signed: <true|false>             # for integers
            range: [<min>, <max>]            # for int/float ranges
        - notes: human-readable explanation
    - path: fuzzer.execution_state
      type: list
      description: |
        List of execution state definitions, they are either values, predicates, or sum.
        Each definition takes up a value in the execution state tuple.
        - type: predicate # boolean expression using <execution_value_name> and real values, operators: ==, !=, <, >, <=, >=, &&, ||
        - expr: # boolean expression using <execution_value_name> and real values, operators: ==, !=, <, >, <=, >=, &&, ||

        - type: value # last value of the given execution value name
        - name: <execution_value_name>

        - type: sum # sum of all values seen for the given execution value name
        - name: <execution_value_name>

        - type: counter # count of how many times the boolean expression is true
        - expr: # boolean expression using <execution_value_name> and real values, operators: ==, !=, <, >, <=, >=, &&, ||

        - type: set # set of all values seen for the given execution value name
        - name: <execution_value_name>
    - path: generator_agent.grammar_prompt
      type: string
    - path: generator_agent.goal_prompt
      type: string

fuzzer:
  time_limit: 30
  execution_limit: 0
  per_run_timeout: 5
  mutations_per_seed: 4
  round_length: 10
  seed_inputs:
    - '0,1 0,2

      9

      '
    - '1,0 2,2

      9

      '
    - '4,1 4,2

      9

      '
    - '7,1 7,2

      9

      '
    - '9

      '
    - '666

      '
    - '2,1 2,2

      9

      '
  stdout: false
  execution_values:
    - name: board_snapshot
      read:
        mode: register_deref
        capture_pc_offset: 9383
        reg: rcx
        ptr_size: 8
        size: 64
      valid_values:
        type: bytes
        alphabet:
        - 46
        - 97
        - 98
        - 99
        - 100
        - 101
        - 102
        - 103
        - 104
        - 105
        - 106
        - 107
        - 108
        length: 64
      notes: Reads the 8x8 board (row-major x*8+y) by dereferencing RCX after it is
        loaded in getPiece.
    - name: ptr_array_ptr
      read:
        mode: mem_offset
        capture_pc_offset: 9383
        offset_from_image: 24584
        size: 8
      valid_values:
        type: int
        signed: false
        range:
        - 0
        - 18446744073709551615
      notes: Read the global ptr_array pointer stored at image+0x6008.
    - name: rcx_at_getPiece
      read:
        mode: register_direct
        capture_pc_offset: 9383
        reg: rcx
        size: 8
      valid_values:
        type: int
        signed: false
        range:
        - 0
        - 18446744073709551615
      notes: Capture RCX register after it is loaded with ptr_array in getPiece.
    - name: board_snapshot_display
      read:
        mode: register_deref
        capture_pc_offset: 8845
        reg: rdx
        ptr_size: 8
        size: 64
      valid_values:
        type: bytes
        alphabet:
        - 46
        - 97
        - 98
        - 99
        - 100
        - 101
        - 102
        - 103
        - 104
        - 105
        - 106
        - 107
        - 108
        length: 64
      notes: Reads board memory by dereferencing RDX after it is loaded in displayboard
        when printing rows.
  execution_state:
  - type: value
    name: rcx_at_getPiece
  - type: value
    name: ptr_array_ptr
  - type: predicate
    expr: rcx_at_getPiece == ptr_array_ptr
  - type: value
    name: board_snapshot
  - type: set
    name: board_snapshot
  - type: value
    name: board_snapshot_display

corpus_stat_tracker:
  snapshot_interval_seconds: 10

target:
  binary: 'samples/CROMU_00005'
  rootfs: 'rootfs/x8664_linux_glibc2.39'

input:
  method: 'stdin'

output:
  dir: 'out'

generator_agent:
  model: 'gpt-4.1-mini'
  system_prompt: |
    You are a mutation agent for a agent-driven fuzzer.
    Your job: given a seed input and feedback (good/bad examples), produce a diverse list of input mutations that are more like the good examples and less like the bad ones, with the goal of increasing execution state coverage.

    You will be given feedback from a critic agent that will guide you toward deeper execution states, make sure to follow the most recent instructions.

    Output format:
    - Return ONLY a JSON object that matches this schema: {"mutations": [string, ...]}.
    - Each element in "mutations" is a single test input as a UTF-8 string (it will be converted to bytes by the harness).
    - Do not include explanations, comments, or code fences.
  grammar_prompt: |
    "Input grammar for CROMU_00005 (board game parser):\n- Move format\
    \ (exactly 7 characters before newline): <X>,<Y> <X>,<Y>\\n\n  - X and Y are single\
    \ ASCII digits '0'..'7' representing coordinates on an 8x8 board.\n  - The exact\
    \ byte layout is: DIGIT (0-7), 0x2C ',' , DIGIT (0-7), 0x20 ' ' , DIGIT (0-7),\
    \ 0x2C ',' , DIGIT (0-7), followed by a terminating newline (0x0A).\n  - The generator\
    \ MUST enforce that each coordinate digit is in the range 0-7 and that the length\
    \ (excluding newline) is 7.\n- Special commands (single-line alternatives):\n\
    \  - \"9\\n\" (single char '9' then newline) -- display the board (parseUserInput\
    \ returns code 2).\n  - \"666\\n\" (three characters '6','6','6' then newline)\
    \ -- quit command (parseUserInput returns code 3).\n- Notes/constraints:\n  -\
    \ Always terminate inputs with a single newline character (0x0A).\n  - Do NOT\
    \ produce other lengths: valid move lines must be 7 bytes + newline; display and\
    \ quit are 1+newline and 3+newline respectively.\n  - Coordinates must be ASCII\
    \ digits between '0' and '7'.\n  - The generator should avoid embeddings of non-printable\
    \ bytes except newline.\n\nGenerator goals for producing smart mutations:\n- Produce\
    \ inputs that set specific board_snapshot patterns by moving pieces. Examples:\
    \ move a pawn from y=1 to y=3 (two-step), move a knight (L-shape), or moves that\
    \ capture (if possible).\n- Preserve the move syntax while mutating coordinates\
    \ to explore board squares (mutate only the four digit positions).\n- Generate\
    \ both syntactically valid but illegal-in-game moves (to test parsing and rejection)\
    \ and syntactically valid legal moves (to advance board state).\n- Generate special\
    \ command inputs (\"9\\n\" and \"666\\n\") to trigger display and quit behaviors.\n\
    - Ensure coordinate digits are in '0'..'7'. For move-targeted generation prefer\
    \ values that hit different x,y combinations to produce diverse board snapshots.\n\
    - When aiming to produce a certain board_snapshot, mutate digits so that the move's\
    \ src points to a square that currently contains a movable piece (x*8+y) and dst\
    \ points to a valid destination for that piece type (e.g., knight L-shapes, pawn\
    \ forward 1 or 2 steps)."
  goal_prompt: |
    Generator agent goals (short):

    1) Create syntactically valid moves: format DIGIT,'',''DIGIT '' '' DIGIT,'',''DIGIT
    + newline. Coordinates 0-7.

    2) Produce inputs that will change the board_snapshot execution value (i.e., legal
    moves for the current team). Prioritize moves from white-side squares (src y==1
    for pawns, src y==0 for back-rank pieces) so that the performMove path succeeds
    and board bytes change.

    3) Also produce valid but illegal moves to exercise rejection code paths (parse
    succeeds but performMove returns 0).

    4) Include the special control commands ''9\n'' and ''666\n''.

    Mutation constraints: only mutate the coordinate digit bytes (positions 0,2,4,6
    of the line) and preserve separators and newline. Keep digits within 0-7.


    Explicit state-targeted tasks for the generator:

    - Produce inputs that, after execution, result in a different board_snapshot (the
    set of board bytes should change).

    - Produce inputs that flip the piece at a chosen source index (x*8+y) to ''.''
    and create the same piece at the destination index.

    - Prefer small, valid coordinate edits (neighboring squares, knight jumps, pawn
    2-step) to maximize reachability while preserving validity.

summarizer_agent:
  model: 'gpt-5-mini'
  system_prompt: |
    You are a summarizer agent. Your task is to analyze all the mutation results from a fuzzer. 
    You are given two lists:
    1. Failed mutations (did not expand coverage).
    2. Successful mutations (expanded coverage).

    Your goal is to produce a concise, structured summary of the mutation results.

    ### Instructions:
    - Identify common **patterns in failures** (e.g., repeated sources, small shifts, 
      horizontal/vertical moves, etc.).
    - Identify common **patterns in successes** (e.g., diagonal jumps, moves from certain 
      rows/columns).
    - Provide a few **representative examples** of failed and successful mutations 
      (not the full list).

    Keep the summary short and clear.

    ### Input:
    Failed mutations:
    {failed_mutations}

    Successful mutations:
    {successful_mutations}

    ### Output format:
    Summary of last round:
    - Failed patterns: ...
    - Successful patterns: ...
    - Representative examples:
      - Successful: [...]
      - Failed: [...]

critic_agent:
  server: 'http://localhost:8000'
  thread_id: ''
  binary_path: ''
  results_dir: ''
  initial_prompt: |
    You are a critic for a fuzzing mutation agent. 
    Your job is to analyze the results of a mutation session and provide concise, actionable guidance that will help the mutation agent generate inputs that reach deeper execution states.

    Inputs available to you:
    - The original seed inputs.
    - The mutation agent's generated inputs.
    - Feedback for each input (e.g., "good" if it reached a new execution state, "bad" if it failed or repeated previous states).
    - Any program state signals (e.g., branch coverage, flags, stage counters).

    Your instructions:
    1. Suggest specific directions for the mutation agent:
       - Fields or input sections to focus on mutating.
       - Types of mutations likely to produce new states.
       - Avoid mutations that repeatedly fail.
    2. Keep your message **short, precise, and actionable** — 1–3 sentences MAX.
    3. ONLY return the text of your message to the mutation agent. Do not explain your reasoning outside the message.

    Here are the results of the mutation session: